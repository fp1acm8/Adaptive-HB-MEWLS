function results = run_ls(config)
%RUN_LS Execute the weighted least-squares solver using a configuration struct.
%   RESULTS = RUN_LS(CONFIG) performs the HB-spline weighted least squares
%   solve with penalisation described in CONFIG. The configuration struct is
%   typically generated by adaptivehb.config.load_config. RESULTS is a struct
%   containing diagnostic information about the adaptive loop.
%
%   This function does not rely on workspace globals; all inputs are supplied
%   through CONFIG. Dataset paths are resolved relative to the repository
%   root via the configuration loader.

arguments
    config (1, 1) struct
end

% -------------------------------------------------------------------------
% Extract solver-specific settings
% -------------------------------------------------------------------------
ls_defaults = struct('lambda_pen', 1e-12, 'debug', false);
if isfield(config, 'solvers') && isfield(config.solvers, 'ls')
    ls_config = merge_structs(ls_defaults, config.solvers.ls);
else
    ls_config = ls_defaults;
end
DEBUG = logical(ls_config.debug);
lambda_pen = ls_config.lambda_pen;

% -------------------------------------------------------------------------
% Load dataset
% -------------------------------------------------------------------------
if ~isfield(config, 'dataset')
    error('adaptivehb:solvers:MissingDataset', ...
        'The configuration does not define a dataset section.');
end

dataset = adaptivehb.solvers.load_dataset(config.dataset);
M = dataset.num_points;
data = dataset.data;
f_true = dataset.f_true;
f = dataset.f_noise;
is_outlier = dataset.is_outlier;

fprintf('Dataset caricato: %s (formato: %d colonne)\n', ...
    dataset.relative_path, dataset.expected_cols);
fprintf('Numero di punti: %d\n', M);
if dataset.expected_cols == 5
    fprintf('Outliers marcati: %d (%.2f%%)\n', sum(is_outlier), ...
        100 * sum(is_outlier) / M);
end

% -------------------------------------------------------------------------
% Problem and discretisation data
% -------------------------------------------------------------------------
problem_data = build_problem_data();
method_data = build_method_data(config);
adaptivity_data = build_adaptivity_data(config);

[hmsh, hspace, geometry] = adaptivity_initialize_laplace(problem_data, method_data);

% -------------------------------------------------------------------------
% Adaptive loop
% -------------------------------------------------------------------------
weight = ones(1, M) / M;
results_matrix = [];
tol_satisfied = false;
space_stuck = false;

while true
    lev = hspace.nlevels;
    ndof = hspace.ndof;

    if DEBUG
        fprintf('\n=== Livello %d | ndof = %d ===\n', lev, ndof);
        disp('Computing weighted least squares solution...');
    end

    [QI_coeff, cond_num] = getcoeff_weighted_least_squares_pen( ...
        hspace, hmsh, data, f, lambda_pen, weight);

    if DEBUG
        disp('Solution computed...');
        disp('Evaluating solution at data points...');
    end

    QI = sp_eval_alt(QI_coeff, hspace, data);
    error_val = abs(f_true - QI');

    max_err_all = max(error_val);
    L2_err_all = norm(error_val, 2) / sqrt(numel(error_val));

    no_out_mask = (is_outlier == 0);
    if any(no_out_mask)
        error_no_out = error_val(no_out_mask);
        max_err_no_out = max(error_no_out);
        L2_err_no_out = norm(error_no_out, 2) / sqrt(numel(error_no_out));
    else
        max_err_no_out = NaN;
        L2_err_no_out = NaN;
    end

    results_matrix = [results_matrix; lev, ndof, max_err_all, L2_err_all, ...
        max_err_no_out, L2_err_no_out, cond_num];

    if DEBUG
        fprintf('cond(S)=%.2e | max_err_all=%.2e | L2_err_all=%.2e\n', ...
            cond_num, max_err_all, L2_err_all);
        fprintf('max_err_no_out=%.2e | L2_err_no_out=%.2e\n', ...
            max_err_no_out, L2_err_no_out);
    end

    % Termination conditions ------------------------------------------------
    if size(results_matrix, 1) > 1
        prev_err = results_matrix(end-1, 4);
        improvement = (prev_err - L2_err_all) / prev_err;
        if improvement < 0
            fprintf('> Miglioramento insufficiente (%.3f%%) -> uscita\n', ...
                improvement * 100);
            break;
        end
    end

    if max_err_all <= adaptivity_data.tol
        disp('> Tolleranza globale soddisfatta');
        tol_satisfied = true;
        break;
    end

    if ndof >= adaptivity_data.max_ndof
        warning('Raggiunto ndof max');
        break;
    end

    if lev >= adaptivity_data.max_level
        warning('Raggiunto livello max');
        break;
    end

    above_tol_idx = find(error_val > adaptivity_data.tol);
    if DEBUG
        fprintf('-> marcati %d punti su %d (%.2f%%) con err > %.2f\n', ...
            numel(above_tol_idx), M, 100 * numel(above_tol_idx) / M, ...
            adaptivity_data.tol);
    end

    if isempty(above_tol_idx)
        disp('> Nessun punto da raffinare -> uscita');
        break;
    end

    marked = support_containing_point(hspace, hmsh, data(above_tol_idx, :));
    hmsh_prev = hmsh;
    hspace_prev = hspace;

    [hmsh, hspace] = adaptivity_refine(hmsh, hspace, marked, adaptivity_data);

    if DEBUG
        fprintf('-> raffinati %d supporti | nuovo ndof = %d\n', ...
            numel(marked{lev}), hspace.ndof);
    end

    if hspace.ndof == hspace_prev.ndof
        space_stuck = true;
        disp('> Spazio invariato -> uscita');
        break;
    end
end

% -------------------------------------------------------------------------
% Reporting
% -------------------------------------------------------------------------
print_summary(dataset, results_matrix, adaptivity_data, tol_satisfied, space_stuck);

if exist('QI_coeff', 'var')
    coeffs = QI_coeff;
else
    coeffs = [];
end

results = struct('history', results_matrix, ...
                 'tol_satisfied', tol_satisfied, ...
                 'space_stuck', space_stuck, ...
                 'coefficients', coeffs, ...
                 'geometry', geometry, ...
                 'hspace', hspace, ...
                 'hmsh', hmsh);
end

function problem_data = build_problem_data()
    C = 100;
    normax2 = @(x, y) ((x - .5).^2 + (y - .5).^2);

    problem_data = struct(...
        'geo_name',    'geo_square.txt', ...
        'nmnn_sides',  [], ...
        'drchlt_sides', [1 2 3 4], ...
        'c_diff',      @(x, y) ones(size(x)));

    problem_data.uex = @(x, y) exp(-C * normax2(x, y));
    problem_data.f = @(x, y) 4 * C * (1 - C * normax2(x, y)) .* problem_data.uex(x, y);
    problem_data.g = @(x, y, ind) zeros(size(x));
    problem_data.h = @(x, y, ind) problem_data.uex(x, y);
    problem_data.graduex = @(x, y) -2 * C * cat(1, ...
        reshape(problem_data.uex(x, y) .* (x - .5), [1, size(x)]), ...
        reshape(problem_data.uex(x, y) .* (y - .5), [1, size(x)]));
end

function method_data = build_method_data(config)
    defaults = struct(...
        'degree',      [2 2], ...
        'regularity',  [1 1], ...
        'nsub_coarse', [16 8], ...
        'nsub_refine', [2 2], ...
        'nquad',       [3 3], ...
        'space_type',  'standard', ...
        'truncated',   1);

    if isfield(config, 'method')
        method_data = merge_structs(defaults, config.method);
    else
        method_data = defaults;
    end

    method_data.degree = reshape(method_data.degree, 1, []);
    method_data.regularity = reshape(method_data.regularity, 1, []);
    method_data.nsub_coarse = reshape(method_data.nsub_coarse, 1, []);
    method_data.nsub_refine = reshape(method_data.nsub_refine, 1, []);
    method_data.nquad = reshape(method_data.nquad, 1, []);
    method_data.space_type = char(method_data.space_type);
end

function adaptivity_data = build_adaptivity_data(config)
    defaults = struct(...
        'flag', 'functions', ...
        'mark_param', 0.5, ...
        'mark_strategy', 'MS', ...
        'max_level', 6, ...
        'max_ndof', 50000, ...
        'num_max_iter', 15, ...
        'max_nel', 50000, ...
        'tol', 5e-3, ...
        'adm', 0);

    if isfield(config, 'adaptivity')
        adaptivity_data = merge_structs(defaults, config.adaptivity);
    else
        adaptivity_data = defaults;
    end

    adaptivity_data.flag = char(adaptivity_data.flag);
    adaptivity_data.mark_strategy = char(adaptivity_data.mark_strategy);
end

function print_summary(dataset, results_matrix, adaptivity_data, tol_satisfied, space_stuck)
    if isempty(results_matrix)
        warning('Nessun risultato disponibile per la stampa del sommario.');
        return;
    end

    fprintf('\n%s\n', repmat('=', 1, 80));
    fprintf('RISULTATI FINALI - WEIGHTED LEAST SQUARES\n');
    fprintf('%s\n', repmat('=', 1, 80));

    if dataset.expected_cols == 3
        fprintf('Liv  DOF   Max Err    L2 Err     cond_num\n');
        fprintf('%s\n', repmat('-', 1, 50));
        fprintf('%3d %5d %10.4e %10.4e %10.2e\n', ...
            results_matrix(:, [1, 2, 3, 4, 7])');
    else
        fprintf('Liv  ndof   max_err_all    L2_err_all   max_err_no_out    L2_err_no_out   cond_num\n');
        fprintf('%s\n', repmat('-', 1, 80));
        fprintf('%3d %5d %14.4e %14.4e %14.4e %14.4e %10.2e\n', results_matrix');
    end

    fprintf('\n%s\n', repmat('=', 1, 50));
    fprintf('ELABORAZIONE COMPLETATA\n');
    fprintf('Dataset: %s\n', dataset.relative_path);
    fprintf('Livelli finali: %d\n', size(results_matrix, 1));
    fprintf('DOF finali: %d\n', results_matrix(end, 2));
    fprintf('Errore finale (all): %.4e\n', results_matrix(end, 4));
    fprintf('Tolleranza soddisfatta: %d | Spazio invariato: %d\n', ...
        tol_satisfied, space_stuck);
    fprintf('Tol target: %.2e\n', adaptivity_data.tol);
    fprintf('%s\n', repmat('=', 1, 50));
end

function merged = merge_structs(defaults, overrides)
    merged = defaults;
    fields = fieldnames(overrides);
    for idx = 1:numel(fields)
        merged.(fields{idx}) = overrides.(fields{idx});
    end
end
